# Multi-level-scheduling-queue
note error :- *Ɵ is ti.

The mulƟ-level feedback queue (MLFQ) is a CPU scheduling algorithm that assigns priority levels to processes and uses mulƟple queues to manage the execuƟon order. The algorithm is designed to provide beƩer performance and responsiveness by dynamically adjusting the priority of processes based on their behaviour. 
Here is an explanaƟon of how the MLFQ CPU scheduling algorithm works: 
1. Priority Levels: The MLFQ algorithm divides processes into mulƟple priority levels. Each level has a different priority 
assigned to it. Typically, the highest priority level is given to interacƟve processes that require quick responses, while lower 
priority levels are assigned to batch processes or CPU-intensive tasks. 
2. Queues: The algorithm maintains mulƟple queues, with each queue corresponding to a different priority level. The number of queues can vary depending on the system configuraƟon and requirements. The highest priority queue is serviced first, followed by lower priority queues. 
3. Scheduling: IniƟally, all processes enter the highest priority queue. The scheduling algorithm selects a process from the highest priority queue for execuƟon. The selected process is assigned a fixed Ɵme quantum (also known as a Ɵme slice) to run on the CPU. 
4. Time Quantum: The Ɵme quantum is the maximum amount of Ɵme a process can run in a single burst. If a process completes its execuƟon within the Ɵme quantum, it is considered to have voluntarily relinquished the CPU. However, if a process exceeds its Ɵme quantum, it is pre-empted and moved to the next lower priority queue. 
5. PromoƟon and DemoƟon: The MLFQ algorithm employs promoƟon and demoƟon mechanisms to dynamically adjust the priority of processes based on their behaviour. If a process uses its enƟre Ɵme quantum without compleƟng, it suggests that it is CPU-bound and is demoted to the next lower priority queue. This prevents long-running processes from hogging the CPU and allows other processes to get a chance to execute. 
6. Aging: Aging is another feature of the MLFQ algorithm that prevents starvaƟon. It gradually increases the priority of processes that have been waiƟng in a lower priority queue for a long Ɵme. Aging ensures that all processes eventually get a chance to run, even if they are iniƟally placed in lower priority 
queues. 
7. Feedback: The MLFQ algorithm uses feedback to make scheduling decisions. Feedback refers to the informaƟon collected during the execuƟon of processes, such as the number of Ɵmes a process has been pre-empted or the amount of CPU Ɵme it has consumed. This feedback helps determine the behaviour of processes and influences their priority adjustments. 
8. Queue SelecƟon: When a process completes its Ɵme quantum or performs a blocking I/O operaƟon, it is moved to a lower priority queue. The selecƟon of the target queue for demoƟon depends on the system policy. For example, a simple policy could move the process to the next lower priority queue, while a more sophisƟcated policy might consider the process's history or behaviour before deciding the new queue. 
9. Pre-empƟon: Pre-empƟon occurs when a higher priority process becomes available for execuƟon. In such cases, the running process is pre-empted and moved to a lower priority queue. Pre-empƟon ensures that processes with higher priority are given precedence and allows for beƩer responsiveness.
 10. Repeat: The process of selecƟng a process from the highest priority queue, execuƟng it for a Ɵme quantum, and moving it to a lower priority queue conƟnues unƟl all processes have completed their execuƟon or there are no more processes in any of the queues.
By uƟlizing mulƟple queues, priority adjustments, Ɵme quantum, and pre-empƟon, the MLFQ algorithm aims to strike a balance between providing quick response Ɵmes for interacƟve processes and efficiently uƟlizing CPU resources for longer-running tasks. It adapts the scheduling based on the behaviour of processes, allowing for dynamic prioriƟzaƟon and improved system performance.
